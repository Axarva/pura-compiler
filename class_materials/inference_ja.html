<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>Pura Compiler: HM Type Inference (JP)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/serif.min.css" id="theme">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css">

    <style>
        :root {
            --r-main-font: 'Noto Sans JP', sans-serif;
            --r-heading-font: 'Noto Serif JP', serif;
            --r-code-font: 'Fira Code', monospace;
            --r-background-color: #fdfdfd;
            --accent-color: #005fcc;
            --error-color: #d73a49;
        }
        .reveal {
            background-color: var(--r-background-color);
            background-image: linear-gradient(rgba(0, 0, 0, 0.02) .1em, transparent .1em), linear-gradient(90deg, rgba(0, 0, 0, 0.02) .1em, transparent .1em);
            background-size: 2em 2em;
            font-family: var(--r-main-font);
            color: #333;
            font-size: 30px; 
        }
        .two-column { display: flex; gap: 40px; align-items: flex-start; justify-content: center;}
        .two-column > div { flex: 1; }
        .code-block { background-color: #fff; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .highlight { color: var(--accent-color); font-weight: bold; }
        .concept-box { padding: 20px; border: 2px solid #eee; border-radius: 8px; margin-bottom: 20px; background: white; }
        .math-term { font-family: var(--r-code-font); background: #eee; padding: 2px 5px; border-radius: 4px; }
        
        /* Diagrams for traces */
        .trace-step { font-size: 0.8em; border-left: 3px solid var(--accent-color); padding-left: 15px; margin-bottom: 15px; text-align: left;}

        /* Increase code font size for readability */
        .reveal code {
            font-size: 1.2em !important; /* Bump up from default */
            line-height: 1.4 !important;
        }

        /* Fix for "LaTeX" rendering using standard HTML */
        .math-rule {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.1em;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .math-symbol {
            font-style: normal;
            font-weight: bold;
            color: #444;
        }
        .pyramid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }
    
        /* The bottom row wrapper */
        .bottom-row {
            display: flex;
            gap: 40px;
            justify-content: center;
            width: 100%;
        }

        /* Common style for boxes */
        .concept-box {
            flex: 1;
            min-width: 300px; /* Ensures they don't get too squished */
            max-width: 45%;   /* Prevents them from being too wide */
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            
            <section>
                <h1>Hindley-Milner</h1>
				<h1>型推論</h1>
                <h3>Puraコンパイラを賢くする</h3>
                <p style="font-size: 0.7em; margin-top: 40px;">ティムシナ　アサルヴァ | 情報メディア特別演習１</p>
            </section>

            <section>
                <h2>目標：<span class="highlight">自動推論</span> (Deduction)</h2>
                <p>ユーザーが全ての型を書かなくても、コンパイラが自動的に型を決定　できるようにします。</p>
                <div class="two-column" style="margin-top: 40px;">
                    <div class="code-block fragment">
                        <pre><code class="language-haskell">-- ユーザーのコード:
let map f list = ...</code></pre>
                        <p style="font-size: 0.6em">簡潔で綺麗</p>
                    </div>
                    <div style="align-items:center; font-size:2em;"> &rarr;</div>
                    <div class="code-block fragment">
                        <pre><code class="language-haskell">-- コンパイラの解釈:
forall a b. (a -> b) 
         -> List a 
         -> List b</code></pre>
                        <p style="font-size: 0.6em">安全で多相的</p>
                    </div>
                </div>
            </section>

            <section>
                <h2>HM法の3つの柱</h2>
                <p>このアルゴリズムは、3つの再帰的な操作で構成されています。</p>
                <div class="pyramid-container">
                        <div class="concept-box fragment">
                            <h4>1. Instantiate (インスタンス化)</h4>
                            <p style="font-size:0.7em">「展開」</p>
                            <p style="font-size:0.6em">汎用的な <code>forall a</code> を新しい変数 <code>(t_0, t_1)</code> に置き換えます。</p>
                        </div>
                        <div class="bottom-row">
                            <div class="concept-box fragment">
                                <h4>2. Unify (単一化)</h4>
                                <p style="font-size:0.7em">「解決」</p>
                                <p style="font-size:0.6em">2つの型を同じにするための「代入」を見つけます。</p>
                            </div>
                            <div class="concept-box fragment">
                                <h4>3. Generalize (汎化)</h4>
                                <p style="font-size:0.7em">「梱包」</p>
                                <p style="font-size:0.6em">解決した変数を再び <code>forall Scheme</code> に戻します。</p>
                            </div>
                        </div>
                </div>
            </section>

            <section>
                <h2>主要なデータ構造</h2>
                <table style="font-size: 0.7em; width: 100%;">
                    <thead>
                        <tr style="background: #eee;">
                            <th>Type (型)</th>
                            <th>Haskell表現</th>
                            <th>役割</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Type</b></td>
                            <td><code class="language-haskell">TInt | TArr | TVar String</code></td>
                            <td>パズルのピース。<br> <code class="language-haskell">TVar "t1"</code> は未知の型です。</td>
                        </tr>
                        <tr>
                            <td><b>Scheme</b></td>
                            <td><code class="language-haskell">Forall [String] Type</code></td>
                            <td>設計図。<br> 多相性を可能にします。</td>
                        </tr>
                        <tr>
                            <td><b>Subst</b></td>
                            <td><code class="language-haskell">Map String Type</code></td>
                            <td>解答キー（代入）。<br> 例: <code>{"t1": TInt}</code></td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section>
                <h3>規則：関数適用 (App)</h3>
                <p style="font-size: 0.7em;">形式的な推論規則をHaskellに対応させます。</p>
                
                <div class="two-column">
                    <div>
                        <h4>形式的な規則</h4>
                        <div class="math-rule">
                            &Gamma; &#8866; e<sub>1</sub> : &tau;<sub>1</sub> &rarr; &tau;<sub>2</sub>
                            <br>
                            &Gamma; &#8866; e<sub>2</sub> : &tau;<sub>1</sub>
                            <hr style="border-top: 1px solid black; margin: 10px 0;">
                            &Gamma; &#8866; e<sub>1</sub> e<sub>2</sub> : &tau;<sub>2</sub>
                        </div>
                        <p style="font-size: 0.6em;">
                            <b>論理:</b> <i>e1</i>が「<i>t1</i>から<i>t2</i>への関数」で、引数<i>e2</i>が<i>t1</i>なら、結果は<i>t2</i>になります。
                        </p>
                    </div>
                    <div>
                        <h4>Inference.hs (実装)</h4>
                        <pre><code class="language-haskell" data-trim data-line-numbers="4,8">
            -- inferExpr ... (Apply e1 e2) ->
            -- 1. 関数の推論 (e1)
            (s1, t1) <- inferExpr env e1
            -- 2. 引数の推論 (e2)
            (s2, t2) <- inferExpr env e2
            -- 3. 単一化 t1 ~ (t2 -> tv)
            unify (apply s2 t1) (TArr t2 tv)
                        </code></pre>
                    </div>
                </div>
            </section>

            <section>
                <h3>規則：変数の参照 (Var)</h3>
                
                <div class="two-column">
                    <div>
                        <h4>形式的な規則</h4>
                        <div class="math-rule">
                            x : &sigma; &isin; &Gamma;
                            <hr style="border-top: 1px solid black; margin: 10px 0;">
                            &Gamma; &#8866; x : &sigma;
                        </div>
                        <p style="font-size: 0.6em;">
                            <b>論理:</b> 環境内に変数<i>x</i>があり、型スキーム<i>&sigma;</i>を持つなら、それをインスタンス化します。
                        </p>
                    </div>
                    <div>
                        <h4>Inference.hs (実装)</h4>
                        <pre><code class="language-haskell" data-trim>
            -- inferExpr ... (Var name) ->
            case Map.lookup name env of
            -- ローカル環境で見つかった場合
            Just t -> return (Map.empty, t)
            -- グローバル環境で見つかった場合 (Scheme)
            Nothing -> case Map.lookup name global of
                Just scheme -> do
                t <- instantiate scheme
                return (Map.empty, t)
                        </code></pre>
                    </div>
                </div>
            </section>

            <section>
                <h3>実装済み規則の概要</h3>
                <p style="font-size: 0.7em;">PuraにおけるHM規則の適用状況。</p>

                <div style="font-size: 0.7em; text-align: left;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr style="border-bottom: 1px solid #ccc;">
                            <th style="padding: 10px;">形式規則</th>
                            <th style="padding: 10px;">Puraでの状況</th>
                            <th style="padding: 10px;">実装場所</th>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><b>[VAR]</b> Variable</td>
                            <td style="color: green; padding: 10px;">&#10004; 完全サポート</td>
                            <td style="padding: 10px;"><code>Inference.hs</code> (Var)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><b>[APP]</b> Application</td>
                            <td style="color: green; padding: 10px;">&#10004; 完全サポート</td>
                            <td style="padding: 10px;"><code>Inference.hs</code> (Apply)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><b>[ABS]</b> Abstraction</td>
                            <td style="color: orange; padding: 10px;">~ トップレベルのみ</td>
                            <td style="padding: 10px;"><code>TypeChecker.hs</code> (inferFunction)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><b>[LET]</b> Let-Binding</td>
                            <td style="color: orange; padding: 10px;">~ トップレベルのみ</td>
                            <td style="padding: 10px;"><code>TypeChecker.hs</code> (Global Declarations)</td>
                        </tr>
                    </table>
                    <div style="margin-top: 20px; font-style: italic; color: #555;">
                        * 注：Puraは現在、トップレベル定義と式を分けているため、推論ループが単純化されています。
                    </div>
                </div>
            </section>

            <section>
                <h2>単一化：推論エンジン</h2>
                <p style="font-size: 0.7em;"><code>unify :: Type -> Type -> Either String Subst</code></p>
                <p>この関数は、方程式 <span class="math-term">t1 ~ t2</span> の解決を試みます。</p>
                
                <div class="two-column">
                    <div class="fragment">
                        <h4>成功例</h4>
                        <pre><code class="language-haskell">unify (TVar "a") TInt</code></pre>
                        <p>&darr;</p>
                        <pre><code class="language-haskell">Right [("a", TInt)]</code></pre>
                    </div>
                    <div class="fragment">
                        <h4 style="color:var(--error-color)">出現チェック (Occurs Check)</h4>
                        <pre><code class="language-haskell">unify (TVar "a") (TList (TVar "a"))</code></pre>
                        <p>&darr;</p>
                        <p style="color:var(--error-color); font-size: 0.6em;"><b>エラー：無限型 (Infinite Type)</b><br>a = [a] = [[a]]...</p>
                    </div>
                </div>
            </section>

            <section>
                <h2>推論モナド</h2>
                <p>状態（新しい変数）を追跡し、エラーを即座に処理する必要があります。</p>
                <pre><code class="language-haskell" data-trim>
type Infer a = 
    ExceptT String                  -- 型不一致で停止
    (StateT InferState Identity) a  -- 新しい変数 "t0", "t1" を追跡
                </code></pre>
                <div class="fragment trace-step" style="margin-top: 20px;">
                    <b>なぜ必要か？</b> <br>
                    再帰の深い場所で <code>unify</code> が失敗しても、<code>ExceptT</code> で即座に処理を中断できます。
                </div>
            </section>

            <section>
                <h2>推論プロセス: <code>f x</code></h2>
                <p style="font-size: 0.7em; margin-bottom: 30px;"><code>f x</code> をどう推論するか</p>
                
                <div class="two-column" style="align-items: center;">
                    
                    <div style="font-size: 0.7em; text-align: left;">
                        <div class="fragment trace-step">
                            1. <b>準備:</b> <br>
                            結果のプレースホルダーを作成: <br>
                            <code class="language-haskell">tv</code> (例: "t9")
                        </div>
                        <div class="fragment trace-step">
                            2. <b>関数の推論 (f):</b> <br>
                            型を取得: <br>
                            <code>t1</code> (例: <code class="language-haskell">Int -> String</code>)
                        </div>
                        <div class="fragment trace-step">
                            3. <b>引数の推論 (x):</b> <br>
                            型を取得: <code class="language-haskell">t2</code> (例: <code>Int</code>)
                        </div>
                    </div>

                    <div style="font-size: 2em; text-align: center; color: #ccc; margin-bottom: 10px;"> &rarr;</div>
                    <div style="font-size: 0.7em; text-align: center;">
                        <div class="fragment trace-step" style="background: #f0f8ff; border-left: 5px solid var(--accent-color); padding: 15px;">
                            4. <b>制約（単一化）:</b> <br>
                            <code class="language-haskell">unify t1 (t2 -> tv)</code>
                            <hr style="border-top: 1px dashed #bbb; margin: 10px 0;">
                            <small>これらは一致するか？</small>
                            <br>
                            <small><code>(Int -> String == Int -> t9)?</code></small>
                        </div>
                        
                        <div class="fragment trace-step" style="border-left-color: green; margin-top: 20px;">
                            5. <b>結果:</b>
                            <b>成功。</b> 
                            <br>
                            <code>tv</code> は <code>String</code> に解決。
                        </div>
                    </div>

                </div>
            </section>

            <section>
                <h2>2パス戦略</h2>
                <p style="font-size: 0.7em;">相互再帰や前方参照の問題を解決します。</p>

                <div class="two-column">
                    <div class="fragment">
                        <h4>パス1：収集</h4>
                        <ul>
                            <li style="font-size: 0.6em">全ての型署名を確認。</li>
                            <li style="font-size: 0.6em"><code>GlobalEnv</code>にロード (Scheme)。</li>
                            <li style="font-size: 0.6em">ユーザーの契約（定義）を信頼。</li>
                        </ul>
                    </div>
                    <div class="fragment">
                        <h4>パス2：検証</h4>
                        <ul>
                            <li style="font-size: 0.6em">各関数の本体に入ります。</li>
                            <li style="font-size: 0.6em">パス1の環境を使って本体を推論。</li>
                            <li style="font-size: 0.6em">「本体の型」と「宣言された型」を単一化。</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h2>なぜ2パスか？（エラーの局所性）</h2>
                <p style="font-size: 0.6em;">シナリオ：関数 <code>g</code> は間違っていますが、<code>f</code> はそれを呼び出しています。</p>
                
                <div class="code-block" style="font-size: 0.5em;">
<pre><code class="language-haskell">g : Int -> Int      -- 宣言（契約）
let g x = "String"  -- 本体（実装 - エラー）

f : Int -> Int
let f x = g x       -- 使用</code></pre>
                </div>

                <div class="fragment trace-step" style="margin-top:20px;">
                    <b>2パスなし:</b> <code>g</code> がおかしいため、<code>f</code> の推論が失敗する可能性があります。
                </div>
                <div class="fragment trace-step" style="border-left-color: green;">
                    <b>2パスあり:</b> 
                    1. <code>f</code> はコンパイル成功（<code>g</code> の契約を正しく使用）。<br>
                    2. <code>g</code> は失敗（本体が契約に違反）。<br>
                    <b>エラーは、バグがある場所で正確に報告されます。</b>
                </div>
            </section>

            <section>
                <h2>今後の展望とロードマップ</h2>
                <p style="font-size: 0.7em; margin-bottom: 30px;">コンパイラの改良とランタイムの構築。</p>

                <div class="two-column">
                    <div class="fragment">
                        <h4 style="color: var(--accent-color);">1. 言語機能の拡張</h4>
                        <ul style="font-size: 0.6em;">
                            <li><b>Let多相:</b> 式内でのローカルなジェネリック変数のサポート。</li>
                            <li><b>無名関数:</b> 真のラムダ式 (<code>\x -> ...</code>) の実装。</li>
                            <li><b>エフェクト推論:</b> 明示的な <code>REQUIRES</code> から自動検出へ。</li>
                            <li><b>エラー改善:</b> 生の単一化エラーではなく、「IntではなくStringが期待されます」等の表示。</li>
                        </ul>
                    </div>
                    <div class="fragment">
                        <h4 style="color: var(--accent-color);">2. アーキテクチャ (MVU)</h4>
                        <ul style="font-size: 0.6em;">
                            <li><b>ランタイム:</b> JSランタイムでの入力処理とリスト管理の実装。</li>
                            <li><b>フェーズ1 (デモ):</b> アーキテクチャ検証のため、完全な<b>ToDoリスト</b>アプリを構築。</li>
                            <li><b>フェーズ2 (目標):</b> 時間が許せば、Pura自身で<b>プレゼンテーションツール</b>を構築。</li>
                        </ul>
                    </div>
                </div>
                
                <div class="fragment" style="margin-top: 40px; padding: 15px; background: #eef; border-radius: 8px; font-size: 0.8em;">
                    <b>次のステップ:</b> 新しい推論エンジンとランタイムを統合し、ToDoアプリを構築する。
                </div>
            </section>

            <section>
                <h2>ご清聴ありがとうございました！</h2>
                <p>質疑応答</p>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            plugins: [ RevealHighlight ],
            transition: 'slide' 
        });
    </script>
</body>
</html>